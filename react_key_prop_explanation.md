# React `key` Prop: 효율적이고 버그 없는 리스트 렌더링의 비밀

React에서 배열을 `map()` 메서드로 순회하여 목록을 렌더링할 때, `key` prop은 단순히 경고 메시지를 없애기 위한 용도가 아닙니다. `key`는 React가 각 항목을 식별하고 추적하는 데 사용하는 **고유한 신분증**과 같습니다. `key`를 올바르게 사용하면 애플리케이션의 성능과 안정성이 크게 향상되지만, 잘못 사용하면 추적이 어려운 버그와 예기치 않은 동작을 유발할 수 있습니다.

이 문서는 `key`의 핵심 개념을 깊이 있게 탐색하고, `KeyPerformanceTest.jsx` 예제를 통해 **배열의 인덱스(`index`)를 `key`로 사용하는 경우**와 **고유 ID를 `key`로 사용하는 경우**의 극명한 차이를 보여줍니다.

## 핵심 개념: `key`는 어떻게 DOM 업데이트에 영향을 미치는가?

리스트의 상태가 변경될 때 (예: 항목의 순서 변경, 추가, 삭제), React는 새로운 가상 DOM 트리를 생성하고 이전 트리와 비교하여 변경 사항을 실제 DOM에 적용합니다. 이 과정을 **재조정(Reconciliation)**이라고 하며, `key`는 이 과정에서 결정적인 역할을 합니다.

-   **고유한 `key`가 있을 때**: React는 `key`를 통해 각 항목의 "정체성"을 파악합니다. 이를 통해 항목이 새로 생성되었는지, 위치가 바뀌었는지, 아니면 삭제되었는지를 명확히 알 수 있습니다.
-   **`key`가 없거나 `index`를 사용할 때**: React는 항목의 정체성을 알 방법이 없어, 오직 배열 내의 "위치(index)"에만 의존하여 변경 사항을 추정합니다.

이 근본적인 차이가 완전히 다른 DOM 조작 전략으로 이어집니다.

---

## 시나리오 1: `index`를 `key`로 사용하는 경우 (문제 발생)

배열의 인덱스를 `key`로 사용하면, React에게 "이 항목의 신분은 배열에서의 위치야"라고 말하는 것과 같습니다. 이는 항목의 순서가 절대 바뀌지 않는 정적인 목록에서는 문제가 없을 수 있지만, 목록이 동적으로 변하는 순간 재앙이 시작됩니다.

### 1. 리스트가 "섞이는(Shuffle)" 경우

**초기 상태:**
사용자가 각 항목의 입력창에 고유한 텍스트를 입력했습니다.

```
[key=0] 항목 A (input: "AAA")
[key=1] 항목 B (input: "BBB")
[key=2] 항목 C (input: "CCC")
```

**"리스트 섞기" 후 배열 상태:**

```
[key=0] 항목 C
[key=1] 항목 A
[key=2] 항목 B
```

**React의 판단과 동작:**
React는 내용을 보지 않고 오직 `key` 값(여기서는 위치)만 봅니다.

1.  **`key={0}`**: React는 이전 DOM과 새 DOM 모두 `0`번 위치에 요소가 있는 것을 확인합니다. React는 이를 같은 노드로 간주하고 **기존 DOM 노드를 재사용**하며 내용만 업데이트하기로 결정합니다.
    -   **결과**: 원래 "항목 A"가 있던 DOM이 재사용됩니다. `<span>` 태그의 텍스트는 "항목 C"로 바뀌지만, 그 옆의 `<input>` DOM 노드와 그 안에 저장된 상태값 "AAA"는 그대로 남게 됩니다.
2.  **`key={1}`**: 같은 원리로, 원래 "항목 B"의 DOM이 재사용되어 텍스트만 "항목 A"로 바뀌고, 입력값 "BBB"는 그대로 유지됩니다.

**최종 화면 결과 (버그 발생!):**
입력창의 상태와 텍스트 레이블이 완전히 뒤섞입니다.

```
[key=0] 항목 C (input: "AAA")  <-- 버그!
[key=1] 항목 A (input: "BBB")  <-- 버그!
[key=2] 항목 B (input: "CCC")  <-- 버그!
```

### 2. 리스트에 항목이 "추가/삭제"되는 경우

-   **맨 앞/중간에 추가**: 모든 후속 항목들의 `index`가 변경되므로, React는 DOM을 잘못 재사용하여 상태가 꼬이는 문제를 일으킵니다. 성능에도 비효율적입니다.
-   **맨 뒤에 추가**: 기존 항목들의 `index`가 유지되므로 유일하게 안전한 `index` key 사용 사례입니다.
-   **항목 삭제**: 삭제된 항목 위치부터 모든 DOM이 잘못 재사용되고, 결국 우리가 원했던 항목이 아닌 마지막 항목이 DOM에서 사라지는 결과를 낳습니다.

#### 관련 코드 (`WithoutKeys` 컴포넌트)

```jsx
// src/components/KeyPerformanceTest.jsx

function WithoutKeys() {
  const [items, setItems] = useState(initialItems);

  const shuffle = () => {
    setItems(_.shuffle(items));
  };

  return (
    <div>
      <h2>Key가 없는 경우 (문제 발생)</h2>
      <button onClick={shuffle}>리스트 섞기</button>
      <ul>
        {items.map((item, index) => (
          /*
            key={index}를 사용하면 React는 "위치"만 보고 컴포넌트를 판단합니다.
            결과: 항목C 옆에 "AAA"가 표시되는 버그 발생!
          */
          <StatefulItem key={index} item={item} />
        ))}
      </ul>
    </div>
  );
}
```

---

## 시나리오 2: 고유하고 안정적인 ID를 `key`로 사용하는 경우 (올바른 방법)

이제 각 데이터가 가진 고유하고 불변하는 `id`('a', 'b', 'c' 등)를 `key`로 사용해 보겠습니다.

### 1. 리스트가 "섞이는(Shuffle)" 경우

**초기 상태:**
마찬가지로 사용자가 입력창에 텍스트를 입력했습니다.

```
[key="a"] 항목 A (input: "AAA")
[key="b"] 항목 B (input: "BBB")
[key="c"] 항목 C (input: "CCC")
```

**"리스트 섞기" 후 배열 상태:**

```
[key="c"] 항목 C
[key="a"] 항목 A
[key="b"] 항목 B
```

**React의 판단과 동작:**
React는 이제 고유한 `key`를 통해 각 항목의 "정체성"을 추적합니다.

1.  **`0`번 위치**: React는 `key="c"`를 확인합니다. 이전 DOM 트리에서 `key="c"`를 가진 요소를 찾아, 그 **DOM 노드 전체(내부 상태를 포함하여)를** 새로운 `0`번 위치로 **이동(Move)**시킵니다.
2.  **`1`번 위치**: React는 `key="a"`를 확인하고, 해당하는 DOM 노드 전체를 찾아 `1`번 위치로 이동시킵니다.
3.  **`2`번 위치**: `key="b"`에 대해서도 동일한 이동 작업을 수행합니다.

**최종 화면 결과 (정상 동작!):**
모든 항목이 자신의 상태를 그대로 간직한 채 올바른 위치로 이동합니다.

```
[key="c"] 항목 C (input: "CCC")  <-- 정상!
[key="a"] 항목 A (input: "AAA")  <-- 정상!
[key="b"] 항목 B (input: "BBB")  <-- 정상!
```

### 2. 리스트에 항목이 "추가/삭제"되는 경우

고유 `key`를 사용하면, 리스트 어디에서든 항목이 추가/삭제될 때 React는 정확하게 작업을 수행합니다.

-   **추가**: 새로운 DOM 노드를 생성합니다.
-   **삭제**: 정확히 해당 `key`를 가진 DOM 노드만 파괴합니다.
-   **이동**: 기존 DOM 노드를 이동시켜 재사용합니다.

모든 작업이 효율적이고 예측 가능하게 이루어집니다.

#### 관련 코드 (`WithKeys` 컴포넌트)

```jsx
// src/components/KeyPerformanceTest.jsx

function WithKeys() {
  const [items, setItems] = useState(initialItems);

  const shuffle = () => {
    setItems(_.shuffle(items));
  };

  return (
    <div>
      <h2>Key가 있는 경우 (정상 동작)</h2>
      <button onClick={shuffle}>리스트 섞기</button>
      <ul>
        {items.map((item) => (
          /*
            key={item.id}를 사용하면 React는 각 컴포넌트의 "정체성"을 추적합니다.
            결과: 항목A는 "AAA"를 정확히 유지!
          */
          <StatefulItem key={item.id} item={item} />
        ))}
      </ul>
    </div>
  );
}
```

---

## 왜 이런 차이가 발생할까?

이러한 차이가 명확하게 드러나는 이유는 `KeyPerformanceTest.jsx` 예제의 `<input>`이 **비제어 컴포넌트(Uncontrolled Component)**이기 때문입니다.

```jsx
<input
  type="text"
  placeholder="여기에 입력하여 상태를 확인하세요"
  style={{ marginLeft: "10px", width: "250px" }}
/>
```

이 `<input>`은 React의 `state`와 연결된 `value` prop이 없습니다. 따라서 사용자가 입력한 값은 React `state`가 아닌 **DOM 노드 자체에 저장**됩니다.

-   `index`를 `key`로 사용하면, React는 DOM 노드를 재사용하므로 그 안에 저장된 `<input>`의 상태(입력값)도 엉뚱하게 재사용됩니다.
-   고유 `id`를 `key`로 사용하면, React는 DOM 노드 자체를 이동시키므로 그 안에 저장된 상태도 함께 올바르게 따라갑니다.

## 결론 및 모범 사례

1.  **`key`는 항상 제공해야 합니다**: `map()`으로 리스트를 렌더링할 때는 반드시 각 요소에 `key` prop을 포함시키세요.
2.  **안정적이고 고유한 `key`를 사용하세요**: 데이터가 가진 고유 식별자(예: 데이터베이스의 ID, UUID 등)가 가장 이상적인 `key`입니다.
3.  **`index`를 `key`로 사용하지 마세요**: 리스트가 정적이고, 순서 변경/추가/삭제가 절대 일어나지 않는다는 100% 확신이 없다면 `index`를 `key`로 사용해서는 안 됩니다.
4.  **`Math.random()`을 `key`로 사용하지 마세요**: `Math.random()`처럼 렌더링할 때마다 변하는 값을 `key`로 사용하면, React는 모든 항목이 새롭다고 착각하여 매번 모든 DOM을 파괴하고 새로 생성합니다. 이는 심각한 성능 저하를 유발합니다.

`key`를 올바르게 이해하고 사용하는 것은 모든 React 개발자가 갖춰야 할 기본기이며, 효율적이고 안정적인 애플리케이션을 만드는 핵심입니다.
